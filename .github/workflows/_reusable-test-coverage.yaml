###========================================
##  Go CI/CD Test Coverage
#==========================================
# This adds support for the test coverage report in Pull Request.
#
# Ref: https://github.com/rytswd/go-cicd-template
#
# Also, this mirrors most of the setup from _reusable-build-changed.yaml

name: Test coverage check for changed module
run-name: Run Go CI/CD for `${{ github.ref }}`, triggered by @${{ github.actor }}

# This is "reusable workflow", meaning the whole job definitions can be used
# without copying the code. In order to use this workflow, refer to this job
# with something like the following
#
# jobs:
#   build:
#     uses: rytswd/go-cicd-template/.github/workflows/reusable-go-cicd-for-pr.yaml@main
#     with:
#       COVERAGE_THRESHOLD: 10
#     secrets: inherit
#
# Ref: https://docs.github.com/en/actions/using-workflows/reusing-workflows
on:
  workflow_call:
    inputs:
      COVERAGE_THRESHOLD:
        required: true
        type: number

jobs:
  build-test-coverage:
    name: Build, Test, and Check Test Coverage
    runs-on: ubuntu-latest
    permissions:
      contents: read
      pull-requests: write
    steps:
      # Initial setup
      - name: Check out
        uses: actions/checkout@08c6903cd8c0fde910a37f88322edcfb5dd907a8 # v5.0.0
        with:
          fetch-depth: 0 # Fetch all history for changed-modules detection

      - name: Fetch base branch for comparison
        run: |
          TARGET_BRANCH="${{ github.base_ref || 'main' }}"
          echo "Fetching comparison target: $TARGET_BRANCH"
          git fetch origin ${TARGET_BRANCH}:refs/remotes/origin/${TARGET_BRANCH}

      - name: Install Go
        uses: actions/setup-go@44694675825211faa026b3c33043df3e48a5fa00 # v6.0.0
        with:
          go-version-file: ./go.mod
          cache: false # Manual cache control below

      # Restore cache
      # Note that this also restores "~/.cache/coverage.txt" to check the
      # coverage diff.
      - name: Restore build cache
        uses: actions/cache/restore@0057852bfaa89a56745cba8c7296529d2fc39830 # v4.3.0
        with:
          path: |
            ~/.cache/coverage.txt
            ~/.cache/go-build
            ~/go/pkg/mod
            bin
          key: ${{ runner.os }}-go-build-${{ hashFiles('**/go.sum', 'Makefile') }}
          restore-keys: |
            ${{ runner.os }}-go-build-

      - name: Build
        run: MODULES="$(make changed-modules)" make build

      # Based on the Makefile definition, this runs the combined coverage at:
      #
      #   coverage/combined.out
      - name: Test and generate coverage report
        run: MODULES="$(make changed-modules)" make test-coverage

      # Get test coverage from cache and coverage.out -- at this point, only
      # work out the summary files, and some environment variables for more
      # checks and steps to take place.
      - name: Get test coverage
        run: |
          ## Step 1. Check previous coverage
          if [[ -f ~/.cache/coverage.txt ]]; then
          prevCoverage=$(cat ~/.cache/coverage.txt | grep total | grep -Eo '[0-9]+\.[0-9]+' || echo "unknown")
          # When it reports "unknown %", it means cache contained malformed data.
          echo "Previous test coverage: ${prevCoverage}% (taken from the cache)"
          else
          echo "Previous test coverage: Not found"
          fi

          ## Step 2. Check new coverage
          # Get into directory so that go tool cover can work
          go tool cover -func=coverage/combined.out > /tmp/coverage.txt
          newCoverage=$(cat /tmp/coverage.txt | grep total | grep -Eo '[0-9]+\.[0-9]+')
          echo "New test coverage:      ${newCoverage}%"

          ## Step 3. Set environment variables
          echo "PREV_COVERAGE=$prevCoverage" >> $GITHUB_ENV
          echo "NEW_COVERAGE=$newCoverage" >> $GITHUB_ENV

      # Create a PR comment when run against PR -- this makes sure the code
      # coverage becomes visible in the comment section, and also, whenever new
      # change is made, the previous test reports will be minimised, leaving the
      # only relevant comment.
      - name: Check and report
        uses: actions/github-script@v6
        if: always() && github.event_name == 'pull_request'
        env:
          COVERAGE_THRESHOLD: ${{ inputs.COVERAGE_THRESHOLD }}
        with:
          retries: 3
          script: |
            const fs = require('fs/promises')

            // 1. Retrieve existing bot comments
            const { data: comments } = await github.rest.issues.listComments({
              ...context.repo,
              issue_number: context.issue.number,
            });
            const botComments = comments.filter(comment => {
              return comment.user.type === 'Bot' &&
                comment.body.includes('Go Test Coverage Report')
            });

            // 2. Safe Value Parsing
            const threshold = parseFloat(process.env.COVERAGE_THRESHOLD) || 0;
            const newCovStr = process.env.NEW_COVERAGE;
            const prevCovStr = process.env.PREV_COVERAGE;
            
            const newCov = parseFloat(newCovStr); // NaN if undefined/empty
            const prevCov = parseFloat(prevCovStr) || 0;

            let overallStatus = "‚ö†Ô∏è SKIPPED (Build Failed?)";
            
            // Only calculate status if we actually have coverage data
            if (!isNaN(newCov)) {
                if (threshold > newCov) {
                    overallStatus = `‚ùå FAIL: Coverage (${newCov}%) < Threshold (${threshold}%)`;
                } else if (prevCov > newCov) {
                    overallStatus = `‚ùå FAIL: Coverage decreased (${prevCov}% -> ${newCov}%)`;
                } else {
                    overallStatus = "‚úÖ PASS";
                }
            }

            // 3. Read Report or Default Message
            let reportContent = "No coverage report generated (Build likely failed).";
            try {
                reportContent = await fs.readFile('/tmp/coverage.txt', 'utf8');
            } catch (e) {
                console.log("Could not read coverage file:", e.message);
            }

            const comment = `### üî¨ Go Test Coverage Report

            #### Summary

            | Coverage Type          | Result                                 |
            | ---------------------- | -------------------------------------- |
            | Threshold              | ${threshold}%                          |
            | Previous Test Coverage | ${prevCovStr || 'Unknown'}%            |
            | New Test Coverage      | ${newCovStr || 'Unknown'}%             |

            #### Status

            ${overallStatus}

            #### Detail

            <details><summary>Show New Coverage</summary>

            \`\`\`
            ${reportContent}
            \`\`\`

            </details>
            `;

            // 4. Minimize old comments
            for (const botComment of botComments) {
              const query = `mutation {
                minimizeComment(input: {classifier: OUTDATED, subjectId: "${botComment.node_id}"}) {
                  clientMutationId
                }
              }`
              await github.graphql(query)
            }

            // 5. Create new comment
            github.rest.issues.createComment({
              ...context.repo,
              issue_number: context.issue.number,
              body: comment
            })

      # Exit with non-zero value if the test coverage has decreased or not
      # reached the threshold.
      - name: Check coverage status
        run: |
          echo "Coverage Threshold:     ${{ inputs.COVERAGE_THRESHOLD }}%"
          echo "Previous test coverage: ${{ env.PREV_COVERAGE || 'Unknown' }}%"
          echo "New test coverage:      ${{ env.NEW_COVERAGE }}%"
          echo

          if (( $(echo "${{ inputs.COVERAGE_THRESHOLD }} > ${{ env.NEW_COVERAGE }}" | bc -l) )); then
            echo "‚ùå ERROR: The test coverage (${{ env.NEW_COVERAGE }}%) is below the threshold (${{ inputs.COVERAGE_THRESHOLD }}%)."
            exit 1
          fi

          PREV_VAL="${{ env.PREV_COVERAGE }}"
          
          # If PREV_VAL is empty or "Unknown", treat it as 0 for safety
          if [[ "$PREV_VAL" == "Unknown" ]] || [[ -z "$PREV_VAL" ]]; then
             PREV_VAL="0"
          fi

          if (( $(echo "$PREV_VAL > 0" | bc -l) )); then
              if (( $(echo "$PREV_VAL > ${{ env.NEW_COVERAGE }}" | bc -l) )); then
                  echo "‚ùå ERROR: The new coverage is worse than the previous coverage ($PREV_VAL% vs ${{ env.NEW_COVERAGE }}%)."
                  exit 1
              fi
          fi

          echo "‚úÖ PASS: The new coverage meets the threshold and has not regressed."

          echo "The new coverage is greater or equal to the previous coverage, and passes the threshold."

      # If triggered from non-PR setup, copy the new coverage as the new cached data.
      - name: Copy coverage information for cache
        if: always() &&
          github.event_name != 'pull_request'
        run: |
          cp /tmp/coverage.txt ~/.cache/coverage.txt

      # If triggered from non-PR setup, save the cache.
      - name: Save cache
        if: always() &&
          github.event_name != 'pull_request'
        uses: actions/cache/save@v3
        with:
          key: ${{ steps.go-cache.outputs.cache-primary-key }}
          # Any location that we generate the test coverage report in
          path: |
            ~/.cache/coverage.txt
            ~/.cache/go-build
            ~/go/pkg/mod